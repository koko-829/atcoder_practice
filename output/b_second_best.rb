# - [B問題 - Second Best](https://atcoder.jp/contests/abc365/tasks/abc365_b)
#     - 書いてみたコード(コード長：198Byte, 処理速度：130ms)

n = gets.to_i
# 入力内容の数字を配列にする
inputs = gets.split.map(&:to_i)
# 配列を降順にしたらindex[1]が2番目に大きい数字になる
sorted = inputs.sort.reverse
second = sorted[1]
# 降順配列で2番目に大きい値が元の配列やとどの位置なのかを1-basedで出力
inputs.each_with_index do |num, index|
  if num == second
    puts index + 1
    exit
  end
end

#     - 良さげ別解(コード長：69Byte, 処理速度：42ms)

n = gets.to_i
a = gets.split.map &:to_i
p a.index(a.max(2)[-1]) + 1

#     - 比較何かしらアウトプット
#         - 私のコードは「入力内容配列にしましょうね→配列を降順にしてindex[1]が2番目に大きい位置になりますね→この値が元の配列で言うたら何番目に当たるのかをループで見つけましょうね」というやつ。
#         - 別解圧倒的に速いし短い
#             - 2行目までは入力内容の取得やから同じ。
#             - 3行目1つずつ見ていくよ。まず`a.index(~) + 1` で入力内容のインデックス位置求めてますな。問題文が何番目ですかやから1-basedにするために+1してる。
#             - 肝心のindexメソッドの引数部分`(a.max(2)[-1])` 。maxメソッドは配列の中から大きい順に引数個分抽出して新しく配列にするやつらしい。つまり`a.max(2)`で`[1番目に大きい要素、2番目に大きい要素]` って感じになってるんですな。で、2番目に必要な要素やからその配列の後ろから1個目の値を取得してると。ここの添字は前から数えると[1]やし後ろから数えると[-1]やからどちらでも良さそうですね。
#         - `.max(n)` は配列の大きい方からn個分取り出して新しい配列として返すメソッド！！
