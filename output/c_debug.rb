# - [**C - Debug**](https://atcoder.jp/contests/abc394/tasks/abc394_c)
#     - 書いてみたコード(コード長：69Byte, 処理速度：2211ms)
#         
#         こっちは処理時間長くなりすぎるからダメ！！って言われたバージョン
s = gets.chomp
while i = s.index("WA")
  s[i,2] = "AC"
end
puts s

#     - 修正して書いてみたコード(コード長：190Byte, 処理速度：121ms)
#         
s = gets.chomp
(s.length).times do |i|
  if s[i,2] == "WA"
    s[i,2] = "AC"
    e = i
    while e > 0 && s[e-1] == "W"
      s[e-1,2] = "AC"
      e -= 1
    end
  end
end
puts s

#     - 良さげ別解(コード長：69Byte, 処理速度：62ms)
#         
S = gets.chomp
puts S.gsub(/W+A/) { |s| 'A' + 'C' * (s.size - 1) }

#     - 比較何かしらアウトプット
#         
#         文字列に潜んでるWAを片っ端からACに変えてください。っていう問題。つまり「WWA」なら最初に「WAC」に変わるねんけど、そしたら1~2文字目でもWAが発生するから「ACC」になるよねという問題。
#         
#         - 自コード
#             - まず最初に書いたのはTLEでダメだった。やっていたのは、とにかく文字列から最初にWAある部分を探して、ACに変える、を片っ端からやっていきましょうという感じ。これのダメだったところは、WAが見つかった場合に、また文字列の一文字目から新しいWAを探し始めるっていう、「文字列異次元に長くてもいちいちそれするの？」な部分かな？
#             - で、考え直して書いてみたコード。まず無造作にWAを探すんじゃなくて、ループ処理で順番に左から確認して行ってWAかどうかを探してみましょうっていう感じにシフトチェンジしてみた。そしたらWA見つかった場合でも、文字列の最初からわざわざ確認し直す必要がないもんね。もし見つかってACに変えた後の話やけど、ここで確認する日宇町があるのは、変えたACの前の文字列がWじゃないかどうか。「W**WA**」→「W**AC**」みたいな感じで変わった時、その前の文字がWやったら「”WA”C」でまたWAの形になりますよねという部分を確認する感じ。ということで一つ前の文字がWかを確認する必要があるなと思ったんやけど、ほんまに確認するべきは一つ前だけ？もし「WWWWA」とかやったら？ACに変わるたびに新しいWAが遡って発生することになるよね〜。やから一つ前の確認するコードでもwhileでループ処理して書いてみたよ。
#         - 別解コード
#             - めっちゃ短くて草。こんな簡単に書けるのか。「WA」を一つずつ確認するんやなくて、「WWWWA」みたいな形の部分を探して、一斉に「ACCCC」の形に変えてしまいましょう。っていうことか…。「W(一文字以上の連続)+Aの形になってるところは結局WがAに変わって、AがCになるでしょ？」っていう、私がループ処理してたところ、結局全部この形に最終的に変化することに気づけてなかった。
#             - `gsub(引数){|ブロック変数| 処理〜〜〜}` は引数にマッチする部分をレシーバから探し出して、それをブロック変数に格納して処理するよ〜っていうメソッド。引数確認すると`(/W+A/)` の正規表現で書かれてますね。`W+` はWが一文字以上連続で続いている部分、Aはそのまま`A`一文字ですね。「WA」だけじゃなくて、「WWWWA」みたいな形もマッチする。
#             - でこれをそのままブロック変数に格納して処理する。 `{ |s| 'A' + 'C' * (s.size - 1) }` は最初の文字をAに変えて、それ以外の残り部分をCに変えるっていう処理ですね。「WA」は「AC」に変わるし、「WWWWWA」は「ACCCCC」に変わるていう感じ。この書き方やったら、わざわざループ処理で地道に確認する必要がないんですね。
